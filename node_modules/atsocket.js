// http://blogs.microsoft.co.il/applisec/2014/03/12/signalr-message-format/
// http://blogs.microsoft.co.il/ranw/2013/02/17/signalr-protocol/
// http://www.asp.net/signalr/overview/guide-to-the-api/handling-connection-lifetime-events

// negotiation URL = https://atomic-trade.com:8080/signalr/negotiate

"use strict";

var url = require('url');
var querystring = require('querystring');
var assert = require('assert');
var https = require('https');
var WebSocket = require('ws');
var validHubs=['chathub','messagehub','tradehub','authhub','historyhub','infohub','wallethub'];

function isHub(hub) {
  return (validHubs.indexOf(hub)>=0);
}

function isMethod(method) {
  return (method.toLowerCase()===method);
}

function isHubArray(arr) {
  return Array.isArray(arr) && (arr.length>0) && (arr.every(isHub));
}

ATSocket.prototype.setBaseURL = function(theURL) {
  this.baseURL=url.parse(theURL);
  this.negotiateURL = getNegotiateURL(this.baseURL, this.connectionData);
}

ATSocket.prototype.setHubs = function(theHubs) {
  assert(isHubArray(theHubs), ['Bad hub list: '+theHubs]);
  this.hubs=theHubs;
  this.connectionData=getConnectionData(theHubs);
  this.negotiateURL = getNegotiateURL(this.baseURL, this.connectionData);
}

function ATSocket() {
  var that=this;

  this.output=console.log;
  this.index=1;
  this.connectionData="";
  this.setBaseURL("https://www.atomic-trade.com:8080/signalr");
  this.setHubs(['chathub','messagehub','tradehub','authhub','historyhub','infohub','wallethub']);
  this.timeoutId = null;
  this.lastreconnect = null;
  this.callbacks = validHubs.reduce(function (prev, cur) {prev[cur]={}; return prev;}, {});
  this.callbacks[null]={};
  this.on = function(hub, method, callback) {
    if (hub===null) {
    } else {
      hub=hub.toLowerCase();
      assert(isHub(hub));
    }
    method=method.toLowerCase();
    assert(isMethod(method));
    assert(this.callbacks[hub]);
    this.callbacks[hub][method]=callback;
  };
  this.rpcQueue=[];
  this.rpc = function(args, callback) {
    if (that.timeoutId) {
      doRPC.call(that, args, callback);
    } else {
      if (that.debug_level>=1) {
        that.output('no timeoutId');
      }
      that.rpcQueue.push([args, callback]);
    }
  }
  this.setOutput = function(newOutput) {
    this.output=newOutput;
  }
  this.debug_level=0;
}

function getConnectionData(hubs) {
  assert(isHubArray(hubs), ['Bad hub list: '+hubs]);

  return JSON.stringify(hubs.map(function (hub) {
    return {'name':hub};
  }));
}

function getNegotiateURL(baseURL, connectionData) {
  return baseURL.format() + "/negotiate?" + querystring.stringify({
    clientProtocol: 1.4,
    connectionData: connectionData,
  });
}

function KeepAliveTimeout() {
  var that=this;

  this.timeoutId=null;
  this.output('KeepAliveTimeout');
  this.ws.close();
}

function reconnect(data) {
  if ((this.lastreconnect===null)||process.hrtime(this.lastreconnect)[0]>=5) {
    this.lastreconnect=process.hrtime();
    negotiationCallback.call(this, data);
  } else {
    var that=this;

    this.lastreconnect=process.hrtime();
    setTimeout(function () {doNegotiation.call(that)}, 5000);
  }
}

function doRPC(args, callback) {
  this.callbacks[null][this.index]=callback;
  var data = {
    H: args[0],
    M: args[1],
    A: args.slice(2),
    I: this.index++
  };
  var message = JSON.stringify(data);
  if (this.debug_level>=2) {
    this.output('send',message);
  }
  this.ws.send(message);
}

function resume() {
  var that=this;

  this.timeoutId=setTimeout(function() {KeepAliveTimeout.call(that)}, this.keepalivetimeout);
  this.rpcQueue.forEach(function(element) {doRPC.call(that, element[0], element[1])});
  this.rpcQueue=[];
}

function negotiationCallback(data) {
  var that=this;

  if (data==null) {
    this.output('failed');
    setTimeout(function () {doNegotiation.call(that)}, 5000);
  } else {
    //this.output('DATA: ' + data);
    var parsedData=JSON.parse(data);
    // URL: /signalr
    // ConnectionToken: [whatever]
    // ConnectionId: [a uuid]
    // KeepAliveTimeout: 20.0 (if this long goes without receiving data, try to reconnect; after this*2/3, raise ConnectionSlow
    // DisconnectTimeout: 30.0 (this is how long we try to reconnect before giving up and sending Disconnected)
    // ConnectionTimeout: 110.0 (not used when a keepalive is in effect)
    // TryWebSockets: true
    // ProtocolVersion: 1.4
    // TransportConnectTimeout: 5.0 (?)
    // LongPollDelay: 0.0 (not used by A-T)
    if ((parsedData.KeepAliveTimeout>1)&&(parsedData.KeepAliveTimeout<=100)) {
      this.keepalivetimeout=parsedData.KeepAliveTimeout*1000;
    } else {
      this.keepalivetimeout=20000;
    }
    var wssURL = this.baseURL;
    wssURL.protocol='wss';
    var connectURL = wssURL.format() + "/connect?" + querystring.stringify({
        transport: 'webSockets',
        clientProtocol: '1.4',
        connectionToken: parsedData.ConnectionToken,
        connectionData: this.connectionData,
//        tid: 1
    });
    this.ws = new WebSocket(connectURL);
    this.ws.on('open', function() {
      resume.call(that);
      if (that.callbacks[null]['open']) {
        that.callbacks[null]['open'](that);
      }
    });
    this.ws.on('message', function(data, flags) {
      // flags.binary will be set if a binary data is received
      // flags.masked will be set if the data was masked
      assert(that.timeoutId);
      clearTimeout(that.timeoutId);
      resume.call(that);
      var obj=JSON.parse(data);
      if (data === '{}') { return; }
      if (that.debug_level>=2) {
        that.output('message',data);
      }
      var handled=false;
      if ((obj.M)&&(Array.isArray(obj.M))) {
        obj.M.forEach(function (m, i, a) {
          if ((m.H)&&(m.M)) {
            m.H=m.H.toLowerCase();
            m.M=m.M.toLowerCase();
            if (isHub(m.H)) {
              var f=that.callbacks[m.H][m.M];
              if ((f)&&(f.apply(that, m.A))) {
                a.splice(i, 1);
              }
            }
          }
        });
        if (Array.isArray(obj.M)&&obj.M.length==0) {
          delete obj.M;
        }
      }
      if (obj.I) {
        var f=that.callbacks[null][obj.I];
        if ((f)&&(f.call(that, obj.R))) {
          delete obj.I;
          delete obj.R;
        }
      }
      if (obj.S) {
        delete obj.S;
      }
      if (obj.G) {
        delete obj.G;
      }
      if (obj.C) {
        delete obj.C;
      }
      if ((that.debug_level<2)             //if we haven't already output the whole message
          &&(Object.keys(obj).length>0)) { //and an unprocessed portion of the message exists
        that.output('message',data);
      }
    });
    this.ws.on('close',function() {
      that.output('closed');
      if (that.timeoutId) {
        clearTimeout(that.timeoutId);
        that.timeoutId=null;
        //setTimeout(function() {doNegotiation.call(that)},5000)
        setImmediate(function() {reconnect.call(that, data)});
      } else {
        setImmediate(function() {reconnect.call(that, data)});
      }
    });
    this.ws.on('error',function() {
      that.output('error');
      if (that.timeoutId) {
        clearTimeout(that.timeoutId);
      }
      setTimeout(function() {doNegotiation.call(that)},5000);
    });
  }
}

function doNegotiation() {
  var that=this;

  //this.output(this.baseURL);
  //this.output(this.negotiateURL);

  var callback = function(response) {
    var data='';

    response.on('data', function (chunk) {
      data+=chunk;
    });
    response.on('end', function (chunk) {
      if (response.statusCode==200) {
        //that.output('HEADERS: ' + JSON.stringify(response.headers));
        negotiationCallback.call(that, data)
      } else {
        that.output('STATUS: ' + response.statusCode);
        negotiationCallback.call(that, null)
      }
    });
  }

  https.get(this.negotiateURL, callback).on('error', function(e) {
    negotiationCallback.call(that, null);
  });
}

ATSocket.prototype.set_debug_level = function(debug_level) {
  //0: none; 1: standard; 2: verbose
  assert(debug_level>=0);
  assert(debug_level<=2);
  this.debug_level=debug_level;
}

ATSocket.prototype.connect = function() {
  doNegotiation.call(this);
  //var negotiateUrl = baseUrl + "/negotiate?" + querystring.stringify({
  //  connectionData: JSON.stringify(cleanedHubs),
  //  clientProtocol: 1.3
  //});
  //var negotiateUrlOptions = url.parse(negotiateUrl, true);
}

module.exports=ATSocket;
